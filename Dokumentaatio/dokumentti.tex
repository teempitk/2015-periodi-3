\documentclass{tktltiki}
\usepackage[pdftex]{graphicx}
\usepackage{subfigure}
\usepackage{url}
\usepackage{graphicx}
\usepackage{tikz}
\usepackage{xytree}
\begin{document}
%\doublespacing
%\singlespacing
\onehalfspacing

\title{Datan pakkausohjelma}
\author{Teemu Pitk‰nen}
\date{\today}

\maketitle

\level{Aineopintojen harjoitustyˆ}
\numberofpagesinformation{\numberofpages\ sivua + \numberofappendixpages\ liitesivua}


\keywords{pakkaus, Huffman-koodaus, move to front, Burrows-Wheeler -muunnos}

\begin{abstract}

T‰ss‰ dokumentissa esitell‰‰n aineopintojen harjoitustyˆn‰ toteutettu kolmitasoinen pakkausohjelma. Ohjelma pohjautuu kolmeen hyvin tunnettuun pakkaus- ja muunnosmenetelm‰‰n. Pakattavaa dataa k‰sitell‰‰n ensin Burrows-Wheeler- ja move to front -muunnoksilla, mink‰ j‰lkeen varsinainen pakkaus tapahtuu Huffman-symbolikoodauksella.

Varsinainen ohjelma on ladattavissa osoitteesta https://github.com/teempitk/2015-periodi-3 .

\end{abstract}

\mytableofcontents




\section{M‰‰rittelydokumentti}
Projektin tavoitteena oli toteuttaa Huffman-koodaukseen pohjautuva pakkausohjelma. Ohjelma saa syˆtteen‰ suoritettavan operaation (pakkaus/purku) ja pakattavan tiedoston nimen. Ohjelma k‰ytt‰‰ muunnos- ja pakkausmenetelmi‰ parametritiedostolle, ja tallentaa tuloksen tiedostoon, jonka nimi on sama kuin alkuper‰inen jatkettuna .teemuzip-p‰‰tteell‰. Alkuper‰inen tiedosto pysyy ennallaan.

Huffman-koodaus on ominaisuuksiensa vuoksi tehokas erityisesti tekstimuotoiselle datalle. Pakkaustehokkuuden parantamiseksi entisest‰‰n ohjelmaa laajennettiin viel‰ toteuttamalla datalle Burrows\---Wheeler -muunnos ja move to front -muunnos ennen varsinaista symbolikoodausta. Ohjelman kompressiopino on siis kolmitasoinen:
\begin{enumerate}
\item Burrows\---Wheeler -muunnos
\item move to front -muunnos
\item Huffman-koodaus
\end{enumerate}

Kompressiopinoon valitut menetelm‰t sopivat projektin aiheeseen hyvin, sill‰ ne vaativat monipuolisesti erilaisten algoritmien ja tietorakenteiden toteuttamista ja soveltamista. Projektissa toteutetut keskeisimm‰t tietorakenteet ovat:
\begin{itemize}
\item Linkitetty lista {\tt (MyLinkedList)}
\item Hajautustaulu {\tt (CodewordDictionary)}
\item Huffman-puu {\tt (HuffmanTree)}
\end{itemize}

Jokainen kompressiopinon elementti on jo itsess‰‰n oma algoritminsa, mutta niiden toteutus vaati monien pienempien ongelmien ratkaisemista. Ohjelmassa on alirutiineina toteutettu mm. seuraavat algoritmit:
\begin{itemize}
\item quicksort (Burrows\---Wheeler -muunnoksen purussa)
\item string quicksort (Burrows-Wheeler -muunnoksessa)
\item insertion sort (Huffman-puun rakennuksessa, k‰ytett‰ess‰ {\tt MyLinkedList}i‰ j‰rjestettyn‰ {\tt insertPreservingOrder}-metodilla)
\end{itemize}

Pakkausohjelmille on t‰rke‰‰ toimia tehokkaasti niin tila- kuin aikavaativuuksien suhteen, koska syˆtteet ovat usein hyvin suuria. K‰ytetyt menetelm‰t toimivat p‰‰osin lineaarisessa ajassa, mist‰ poikkeuksena Burrows-Wheeler -muunnos, joka vaatii keskim‰‰rin $\mathcal{O}(n \log n)$-ajassa toimivia j‰rjest‰misalgoritmeja. Tarkemmin aikavaativuuksia on eroteltu toteutusdokumentissa.

\section{Toteutusdokumentti}
\subsection{Pakkaus}
\subsubsection{Burrows-Wheeler -muunnos (BWT)}
Datalle ensimm‰isen‰ tehty Burrows-Wheeler -muunnos ei pienenn‰ datan kokoa lainkaan, vaan itseasiassa kasvattaa sit‰ nelj‰ll‰ tavulla, ja muunnoksen idea pakkauksessa onkin pelk‰st‰‰n parantaa muiden menetelmien tehokkuutta. Muunnoksen j‰lkeen datassa esiintyy yleens‰ enemm‰n per‰kk‰isi‰ saman tavun toistoja. Muunnoksen voi ajatella toimivan seuraavalla tavalla. Datasta muodostetaan ensin matriisi, jonka jokaisella rivill‰ dataa on "kierretty" yksi pyk‰l‰ eteenp‰in. Jos alkuper‰inen data olisi siis "banana", matriisi olisi seuraava:

\begin{center}
$\left[\begin{tabular}{cccccc}
b & a & n & a & n & a \\
a & n & a & n & a & b \\
n & a & n & a & b & a \\
a & n & a & b & a & n\\
n & a & b & a & n & a\\
a & b & a & n & a & n
\end{tabular}\right]$
\end{center}

Seuraavaksi matriisin rivit j‰rjestet‰‰n akkosj‰rjestykseen:

\begin{center}
$\left[\begin{tabular}{cccccc}
a & b & a & n & a & n\\
a & n & a & b & a & n\\
a & n & a & n & a & b \\
b & a & n & a & n & a \\
n & a & b & a & n & a\\
n & a & n & a & b & a 
\end{tabular}\right]$
\end{center}

Muunnettu data on t‰m‰n matriisin viimeinen sarake, ja datan oikeassa j‰rjestyksess‰ sis‰lt‰v‰n rivin numero, t‰ss‰ siis "nnbaaa", 3. T‰ss‰ projektissa muunnos toteutettiin Wikipedian \ref{bwtwikipedia} artikkelin mukaisesti. K‰yt‰nnˆn toteutuksissa datan koon suhteen neliˆllist‰ matriisia ei tietenk‰‰n toteuteta kokonaan, vaan kunkin matriisin rivin voi esitt‰‰ sanan ensimm‰isen tavun indeksin‰ alkuper‰isess‰ datassa.

Datan luku tiedostosta ja matriisia kuvaavien osoittimien alustus ovat luonnollisesti luokkaa $\mathcal{O}(n)$ niin aika- kuin tilavaativuudeltaan. Matriisin rivien j‰rjestys tapahtuu \ref{spamateriaali} kuvatulla \textit{string quicksort}illa. Pitkien merkkijonojen (tai t‰ss‰ tavutaulukoiden) normaali pikaj‰rjest‰minen ei toimi $\mathcal{O}(n\log n)$-ajassa, sill‰ kahden merkkijonojen vertaaminen ei aina onnistu yhdell‰ operaatiolla, vaan voi vaatia jopa merkkijonon pituuden verran vertailuja. Merkkijonoille muokattu quicksort pit‰‰ rekursiossa mukana myˆs vertailun kohteena olevien merkkijonojen \textit{pisimm‰n yhtenev‰n alkuosan} (longest common prefix, lcp) pituuden, jolloin vertailu osataan aloittaa merkkijonon j‰rkev‰st‰ indeksist‰. T‰llˆin quicksortin aikavaativuus saadaan merkkijonoille toteutumaan ajassa $\mathcal{O}(n\log n)+\Sigma LCP$. T‰ss‰ $\Sigma LCP$ tarkoittaa summaa j‰rjestetyn matriisin kunkin rivin yhteisest‰ etuliitteest‰ yll‰olevaan riviin, siis \textit{banana}-esimerkiss‰ 0 + 1 + 3 + 0  + 0 + 2 = 6. Satunnaisissa ja k‰yt‰nnˆn tapauksissa aakkosto (erilaisten esiintyvien tavujen m‰‰r‰) on yleisesti suuri, jolloin yhteiset alkuosat ovat suhteellisen lyhyit‰, ja aikavaativuus on k‰yt‰nnˆss‰ $\mathcal{O}(n \log n)$. Toteutettu algoritmi vaatii kussakin rekursion tasossa lineaarisen m‰‰r‰n tilaa, ja rekursion keskim‰‰r‰inen syvyys on $\mathcal{O}(n)$, joten myˆs tilavaativuus on t‰ss‰ $\mathcal{O}(n \log n)$, jota voisi luonnollisesti optimoida viel‰ paremmaksi.

Muunnetun datan lukeminen j‰rjestetyst‰ matriisista on nyt $\mathcal{O}(n)$-operaatio, ja samoin datan kirjoitus tiedostoon. Toteutetun Burrows\---Wheeler -muunnoksen per‰kk‰isist‰ operaatioista raskain on siis matriisin rivien pikaj‰rjest‰minen, joka vie aikaa ja tilaa keskim‰‰rin $\mathcal{O}(n \log n)$. Muunnetun tiedoston alkuun lis‰t‰‰n nyt viel‰ alkuper‰isen datan viimeisen tavun osoitin. T‰m‰ tallennetaan 32-bittisen‰ etumerkillisen‰ kokonaislukuna (int), joten suurimmat tiedostot, joille pakkaus voidaan tehd‰ ovat kooltaan $2^{31}-1 \approx$2 gigatavua.





\subsubsection{Move to front -muunnos (MTF)}
Move to front ei vaikuta datan kokoon lainkaan, mutta on oleellinen Burrows\---Wheelerin hyˆdynt‰misess‰ Huffman-koodaukseen. Kuten edell‰ kuvattiin, BWT ei muuta datassa esiintyvi‰ tavuja, vaan pelk‰st‰‰n niiden j‰rjestyst‰. Jos t‰lle muunnetulle datalle ajettaisiin Huffman-koodaus, muunnoksella ei olisi mit‰‰n vaikutusta pakatun datan kokoon, sill‰ symbolikoodauksessa sama merkki korvattaisiin samalla bittijonolla sijainnista riippumatta. (Itseasiassa datan koko kasvaisi hieman lis‰tyst‰ osoittimesta johtuen).

MTF:ssa luodaan ensin kaikki mahdolliset 256 tavua sis‰lt‰v‰ linkitetty lista, niin ett‰ kukin tavu on (etumerkitˆnt‰) arvoaan vastaavassa indeksiss‰. Dataa k‰sitell‰‰n tavu kerrallaan, ja kukin tavu korvataan ensin tavun indeksill‰ edell‰ kuvatussa listassa, mink‰ j‰lkeen tavu siirret‰‰n listan ensimm‰iseksi. MTF hyˆtyy nyt BWT:n tuottamista saman tavun toistoista, sill‰ kaikki toiston tavut ensimm‰ist‰ lukuunottamatta korvataan nollatavulla. Yleisesti tekstiss‰ usein esiintyv‰t tavut korvataan pienill‰ luvuilla, joita esiintyy muunnetussa datassa paljon. Huffman-koodaus puolestaan hyˆtyy t‰st‰ tavujen ep‰tasaisesta jakaumasta.

Esimerkiksi, sanassa \textit{banana} esiintyvien merkkien alkuindeksit listassa ovat

\begin{center}
\begin{tabular}{c|c}
merkki & numeroarvo / indeksi\\
\hline
a & 97\\
b & 98\\
n & 110,
\end{tabular}
\end{center}

ja muunnettu data olisi nyt 98, 98, 110, 1, 1, 1.

Tavulistan luonti alussa vaatii aikaa ja tilaa $\mathcal{O}(m)$, miss‰ $m$ on aakkoston koko, t‰ss‰ projektissa kaikkien erilaisten tavujen m‰‰r‰ eli 256 (vakio). Dataa muuntaessa tavun indeksin selvitys listassa vaatii aikaa $\mathcal{O}(m)$, ja se tehd‰‰n jokaiselle ($n$ kpl) tavulle. Operaation aikavaativuus on siis $\mathcal{O}(mn)=\mathcal{O}(256\cdot n)=\mathcal{O}(n)$. Muunnos vaatii tilaa vain tavulistan ja muunnetun datan tallentamiseen, joten tilavaativuus on $\mathcal{O}(m)+\mathcal{O}(n)=\mathcal{O}(n)$.


\subsubsection{Huffman-koodaus}
Huffman-koodaus on optimaalinen symbolikoodaus datalle, jossa kukin tavu saa sit‰ pidemm‰n koodisanan, mit‰ harvinaisempi se on koodattavassa tekstiss‰. Huffman-koodaukselle erityist‰ on koodisanojen luontitapa, muuten kyseess‰ on t‰ysin tavallinen symbolikoodaus, jossa sama tavu korvataan aina samalla bittijonolla sijainnista riippumatta.

Koodauksen aluksi kunkin tavun esiintymism‰‰r‰ t‰ytyy laskea l‰hdedatassa, johon kuluu aikaa $\mathcal{O}(n)$ ja tilaa $\mathcal{O}(m)$. T‰m‰n j‰lkeen luodaan lista, jossa tavut (niit‰ vastaavat Huffman-puun solmut) ovat esiintymism‰‰riens‰ mukaisesti kasvavassa j‰rjestyksess‰. Puuta rakennetaan siten, ett‰ listasta poistetaan toistuvasti kaksi ensimm‰ist‰ (harvinaisinta) alkiota, luodaan uusi solmu, jonka esiintymism‰‰r‰ksi asetetaan poistettujen yhteenlaskettu esiintymism‰‰r‰, poistetut solmut t‰m‰n lapsiksi, ja laitetaan t‰m‰ uusi solmu oikealle paikalleen listaan. Toisto loppuu, kun listassa on en‰‰ yksi solmu. Esimerkkisanalle banana saadaan siis seuraava puu:

\begin{tabular}{ccc}

\begin{tabular}{c|cc}
solmu & esiintymism‰‰r‰ & koodisana\\
\hline
a & 3 & 1\\
b & 1 & 00\\
n & 2 & 01
\end{tabular}

&

\begin{tikzpicture}[level/.style={sibling distance=20mm/#1}]
	\node [circle,draw] {abn}
		child{ node [circle, draw] {bn}
			child{node [circle, draw]{b}}
			child{node [circle, draw]{n}}
			}
    	child{node [circle, draw]{a}};
\end{tikzpicture}
\end{tabular}

Koodisanat saadaan luettua puusta yksinkertaisesti rekursion avulla. Puuta l‰pik‰yd‰‰n juuresta alkaen, ja rekursion parametrina annetaan aina kertynyt koodisana. Siirrytt‰ess‰ rekursiossa solmun lapseen, kertyneen koodisanan loppuun lis‰t‰‰n 0 jos siirryt‰‰n vasempaan lapseen, ja 1 jos siirryt‰‰n oikeaan lapseen. Lopulta, kun rekursio p‰‰see lehteen asti, lehte‰ vastaavan tavun koodisana on juuri rekursiossa kertynyt bittijono.

Puuta rakentaessa kahden harvinaisimman solmun poistaminen listan alusta ja uuden solmun luominen ovat vakioaikaisia. Uuden solmun sijoittaminen listaan vaatii kuitenkin $\mathcal{O}(m)$-ajan, sill‰ linkitetyss‰ rakenteessa ei voida etsi‰ paikkaa bin‰‰rihakutyylisesti, vaan lis‰‰minen perustuu lis‰ysj‰rjest‰miseen. Edell‰ kuvattu toiminta poistaa listasta kaksi alkiota ja lis‰‰ takaisin yhden, joten kullakin iteraatiolla listan solmujen m‰‰r‰ v‰henee yhdell‰, ja toistoja tarvitaan siis $m-1$ kappaletta. Kokonaisaikavaativuus puun rakentamiselle on siis $\mathcal{O}(m^2)$. T‰ss‰ toteutuksessa $m$ on aina korkeintaan 257 (kaikkien erilaisten tavujen m‰‰r‰ ja tiedoston loppumerkki), joten puun rakennus on itseasiassa vakioaikaista.

Koodisanoja puusta luettaessa puun l‰pik‰ynniss‰ kussakin solmussa k‰yd‰‰n vain kerran. Huffman-puu on aina t‰ysi, joten solmuja on kaikkiaan $2m-1$ kappaletta, siis aikavaativuus on $\mathcal{O}(2m-1)$, ja t‰ss‰ toteutuksessa siis j‰lleen vakioaikaista. Luetut koodisanat tallennetaan taulukkoon, josta kutakin tavua vastaava koodisana saadaan vakioajassa, kun tavua k‰ytet‰‰n taulukon indeksin‰. Kun siis suoritetaan varsinainen datan symbolikoodaus, kunkin datan tavun koodaus vie vakioajan, ja kokonaisaikavaativuus on siten $\mathcal{O}(n)$.

Koska Huffman-koodauksen tuottamat koodisanat ovat erilaiset pakattavasta tiedostosta riippuen, myˆs koodisanat t‰ytyy tallentaa pakattuun tiedostoon, jotta pakkaus voidaan myˆs purkaa. T‰ss‰ ohjelmassa Huffman-pakatun tiedoston koko rakenne on seuraava:

\begin{enumerate}
\item Tiedot koodauksesta

\begin{tabular}{|c|c|c|c|c|c}
\hline
koodinpituus(0) & koodi(0) & koodinpituus(1) & koodi(1) & koodinpituus(2) & ...\\
\hline
\end{tabular}

\begin{tabular}{c|c|c|c|c|c|}
\hline
...& koodi(255) & koodinpituus(256) & koodi(256) &koodinpituus(EOF) & koodi(EOF)\\
\hline
\end{tabular}

\item Varsinainen data koodattuna (t‰ss‰ '+' tarkoittaa koodisanojen konkatenointia)

\begin{tabular}{|c|}
\hline
koodi(data[0])+koodi(data[1])+...+koodi(data[data.length-1])\\
\hline
\end{tabular}
\item Loppuosa

\begin{tabular}{|c|c|}
\hline
koodi(EOF) & t‰yttˆ tasatavuihin 0-tavuilla\\
\hline
\end{tabular}

\end{enumerate}


\subsection{Purku}
Purkuvaihessa operaatiot t‰ytyy suorittaa pakkaukseen n‰hden k‰‰nteisess‰ j‰rjestyksess‰. K‰ytetyt menetelm‰t ovat asymmetrisi‰, eli purkuoperaatiot ovat erilaiset kuin pakkauksen vastaavat.
\subsubsection{Huffman-koodaus}
Huffman-koodauksen purku tapahtuu nyt t‰ysin normaalin symbolikoodauksen tapaan. Ensin tiedoston alusta t‰ytyy lukea koodisanat, joka tapahtuu toistamalla 257 kertaa seuraava proseduuri:

\begin{verbatim}
1. for tavu = 0 to 256
2.     koodinpituus = lue seuraavat 8 bitti‰
3.     koodisana = lue seuraavat koodinpituus bitti‰
4.     lis‰‰ (koodisana, tavu) -pari CodewordDictionaryyn

\end{verbatim}

Koodisanojen m‰‰r‰ ja maksimipituus ovat vakioita, joten koko koodauksen tulkinta tiedoston alusta on vakioaikaista. Kun koodisanat ovat hajautustaulussa, datan purku tapahtuu pelkistetysti seuraavalla algoritmilla

\begin{verbatim}
1. while pakattua dataa j‰ljell‰
2.     lue seuraava bitti puskuriin
3.     if (hajautustaulu sis‰lt‰‰ puskurin bittijonon)
4.         aseta vastaava tavu puretun datan loppuun
5.         tyhjenn‰ puskuri
\end{verbatim}

Algoritmin while-silmukka suoritetaan selv‰sti $\mathcal{O}(n)$ kertaa. Silmukan lohkon operaatiot ovat kaikki keskim‰‰rin vakioaikaisia, joten myˆs koko koodauksen purun aikavaativuus on $\mathcal{O}(n)$.


\subsubsection{Move to front -muunnos}
Move to front on menetelmist‰ samankaltaisin pakkaus- ja purkuvaiheessa. Myˆs purkuvaiheessa kaikki tavut alustetaan ensin listaan, mutta nyt toimitaan pakkausvaiheeseen n‰hden k‰‰nteisesti \--- luetaan ensin "oikean" tavun indeksi pakatusta tiedostosta, luetaan tavu listasta indeksin mukaisesti, ja siirret‰‰n sitten tavu taas listan alkuun ja lis‰t‰‰n se puretun datan loppuun. Kuten pakkauksessa, alustustoimenpiteet vaativat $\mathcal{O}(m)=\mathcal{O}(256)\mathcal{O}(1)$ ajan ja tilan. Dataa k‰sitelless‰ l‰pik‰yd‰‰n linkitetty‰ m-alkioista tavulistaa n-kertaa, ja kokonaisaikavaativuus on, kuten pakkauksessa, $\mathcal{O}(mn)=\mathcal{O}(n)$.

\subsubsection{Burrows\---Wheeler -muunnos}
Burrows-Wheeler -muunnos saadaan purettua seuraavasti: Muistetaan, ett‰ pakattu data vastasi BWT-matriisin viimeist‰ saraketta. Koska matriisin jokainen sarake sis‰lt‰‰ datan kaikki symbolit, ja matriisin rivit olivat aakkosj‰rjestyksess‰, saamme ensimm‰isen sarakkeen yksinkertaisesti j‰rjest‰m‰ll‰ muunnetun datan tavut. Viimeisen sarakkeen lukeminen on tietenkin lineaarinen operaatio, ja ensimm‰inen sarake saadaan pikaj‰rjest‰m‰ll‰ ajassa $\mathcal{O}(n \log n)$. Aiemmin k‰ytetyss‰ \textit{banana}-esimerkiss‰ tied‰mme nyt siis:

\begin{center}
$\left[\begin{tabular}{cccccc}
a & ??? & n\\
a & ??? & n\\
a & ??? & b \\
b & ??? & a \\
n & ??? & a\\
n & ??? & a 
\end{tabular}\right]$
\end{center}

Koska sanat kiert‰v‰t matriisin riveill‰ "ymp‰ri", saamme kaikki alkuper‰isess‰ datassa esiintyneet kahden tavun parit nyt yhdist‰m‰ll‰ (rivin viimeinen tavu)+(rivin ensimm‰inen tavu). Esimerkiss‰mme t‰m‰ tuottaa siis tavuparit na, na, ba, ab, an, an. Tavuparit saadaan oikeaan j‰rjestykseen havaitsemalla, ett‰ tavun $t$ $i$:s esiintym‰ ensimm‰isess‰ sarakkeessa vastaa saman tavun $i$:nnett‰ esiintym‰‰ viimeisess‰ sarakkeessa \--- saman tavun esiintymien keskin‰inen j‰rjestys on kussakin sarakkeessa sama!

Datan purkamiseksi luodaan nyt indeksointi kunkin tavun esiintymispaikoista viimeisess‰ sarakkeessa. T‰m‰ saadaan 256-paikkaisena taulukkona linkitettyj‰ listoja. Sarake k‰yd‰‰n kertaalleen l‰pi, oikea lista lˆydet‰‰n vakioajassa k‰ytt‰en tavun arvoa indeksin‰, ja esiintym‰n indeksi lis‰t‰‰n listan loppuun. Listoja on vakiom‰‰r‰ 256 kappaletta, ja niihin asetetaan $n$ linkitetyn listan alkiota, joten tilavaativuus on $\mathcal{O}(n+256)=\mathcal{O}(n)$.

Indeksointia ja edell‰ mainittua vastaavuusominaisuutta k‰ytt‰en luodaan nyt n-paikkainen taulukko "seuraajat" (tilavaativuus $\mathcal{O}(n))$, jonka indeksiss‰ $i$ on ensimm‰isen sarakkeen $i$:nnen alkion sijainti-indeksi viimeisess‰ sarakkeessa. Havaitaan itseasiassa, ett‰ t‰st‰ seuraa suoraan, ett‰ tavua seuraava tavu on \textit{ensimm‰isen} sarakkeen arvo samassa indeksiss‰. T‰m‰ taulukko saadaan yksinkertaisesti toistamalla seuravaa: lue 1. sarakkeen $i$:s tavu $(\mathcal{O}(1))$, etsi oikea lista edell‰ luodusta indeksoinnista k‰ytt‰en tavun arvoa indeksin‰ $(\mathcal{O}(1))$, lis‰‰ luotavaan taulukkoon indeksiin $i$ listan ensimm‰inen alkio ja poista se samalla listasta.Vakioaikaisia operaatioita toistetaan $n$ kertaa, joten vaiheen aikavaativuus on $\mathcal{O}(n)$.

Luoduilla rakenteilla alkuper‰inen data saadaan nyt purettua helposti \--- muistetaan, ett‰ pakattuun dataan lis‰ttiin myˆs osoitin, joka kertoo miss‰ indeksiss‰ alkuper‰isen datan viimeinen merkki on viimeisess‰ sarakkeessa. Havaitaan, ett‰ alkuper‰isen datan ensimm‰inen merkki sijaitsee samassa indeksiss‰ ensimm‰isess‰ sarakkeessa. Nyt toistetaan vain seuraavaa:
\begin{verbatim}
1. indeksi = viimeisen tavun sijainti viimeisess‰ sarakkeessa
2. for i = 0 to data.length-1
3.     lis‰‰ purettuun dataan ensimm‰inen_sarake[indeksi]
4.     indeksi = seuraajat[indeksi]
\end{verbatim}
Operaation aikavativuus on selv‰sti lineaarinen datan kokoon n‰hden.

\section{K‰yttˆohje}
Ohjelman jar-tiedosto lˆytyy kohteesta {\tt tiralabra/dist/tiralabra.jar}. Ajettaessa ohjelmalle tulee antaa kaksi parametria:
\begin{itemize}
\item "c" tai "d", eli pakataanko (compress) vai puretaanko (decompress)
\item pakattavan tiedoston nimi
\end{itemize}

Pakkauksen esimerkkikomento voisi siis olla esimerkiksi:
\begin{verbatim}
> java -jar tiralabra.jar c ../sampleFiles/alice.txt
\end{verbatim}

ja purkukomento esimerkiksi
\begin{verbatim}
> java -jar tiralabra.jar d ../sampleFiles/alice.txt.teemuzip
\end{verbatim}

Pakkauksen ja purun aikana ohjelma tulostaa tietoa etenemisest‰‰n, edell‰ mainittu pakkauksen esimerkkikomento voi tulostaa esimerkiksi:
\begin{verbatim}
> java -jar tiralabra.jar c ../sampleFiles/alice.txt 
Compression started.
Phase 1/3: Burrows-Wheeler transform started ...		   Finished. Time: 0,369 sec.
Phase 2/3: Move to front transformation started ...		Finished. Time: 0,286 sec.
Phase 3/3: Huffman encoding started ...				            Finished. Time: 0,137 sec.
Compression finished. Total time: 0.818899 sec.
File size reduced from 167518 bytes to 55788 bytes (33,3% of original size).
\end{verbatim}

\section{Testausdokumentti}

\begin{thebibliography}

\bibitem{bwtwikipedia} http://en.wikipedia.org/wiki/Burrows-Wheeler\_transform

\bibitem{spamateriaali}
\end{thebibliography}

\end{document}
